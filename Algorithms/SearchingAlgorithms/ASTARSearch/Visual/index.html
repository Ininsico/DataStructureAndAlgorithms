<!DOCTYPE html>
<html>
<head>
    <title>A* Pathfinding - Cost Breakdown</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background: #111;
            color: white;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(15, 40px);
            gap: 2px;
            margin: 20px auto;
            width: fit-content;
        }
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        .start { background: #00FF7F; }  /* Green */
        .end { background: #FF4500; }    /* Red */
        .wall { background: #333; }      /* Black */
        .open { background: #1E90FF; }   /* Blue */
        .closed { background: #32CD32; } /* Green */
        .path { background: #FFD700; }   /* Gold */
        .cost-label {
            position: absolute;
            font-size: 8px;
            bottom: 2px;
            right: 2px;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            background: #6200EA;
            color: white;
            border: none;
            border-radius: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: scale(1.05);
        }
        #info {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            margin: 10px auto;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <h1>ðŸš€ A* Pathfinding - Cost Breakdown ðŸš€</h1>
    <p><strong>Click cells to place walls â†’ Hit "Find Path" to see the magic!</strong></p>
    
    <div id="grid"></div>
    
    <div>
        <button onclick="placeStart()">Set Start (Green)</button>
        <button onclick="placeEnd()">Set End (Red)</button>
        <button onclick="findPath()">Find Path!</button>
        <button onclick="resetGrid()">Reset</button>
    </div>

    <div id="info">
        <h3>âš¡ How A* Works:</h3>
        <p><strong>f(n) = g(n) + h(n)</strong></p>
        <ul style="text-align: left;">
            <li>âœ… <strong>g(n)</strong> = Actual cost from <span style="color: #00FF7F;">Start</span> to this cell</li>
            <li>âœ… <strong>h(n)</strong> = Estimated cost (heuristic) to <span style="color: #FF4500;">End</span></li>
            <li>âœ… <strong>f(n)</strong> = Total cost (g + h)</li>
        </ul>
        <p><em>A* picks the cell with the <strong>lowest f(n)</strong> at each step!</em></p>
    </div>

    <script>
        const ROWS = 15;
        const COLS = 15;
        let grid = [];
        let start = { row: 0, col: 0 };
        let end = { row: 14, col: 14 };
        let placingStart = false;
        let placingEnd = false;
        let animationSpeed = 50; // ms

        // Initialize grid
        function initGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            grid = [];

            for (let row = 0; row < ROWS; row++) {
                grid[row] = [];
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = () => toggleWall(row, col);
                    gridElement.appendChild(cell);
                    
                    grid[row][col] = {
                        row, col,
                        isWall: false,
                        element: cell,
                        g: Infinity,  // Cost from start
                        h: 0,         // Heuristic to end
                        f: Infinity,  // Total cost (g + h)
                        previous: null
                    };

                    // Add cost label (initially hidden)
                    const costLabel = document.createElement('div');
                    costLabel.className = 'cost-label';
                    costLabel.textContent = '';
                    cell.appendChild(costLabel);
                }
            }

            // Set start and end points
            updateCell(start.row, start.col, 'start');
            updateCell(end.row, end.col, 'end');
        }

        // Update cell appearance
        function updateCell(row, col, type) {
            const cell = grid[row][col].element;
            cell.className = 'cell ' + type;
            
            // Update cost label if not start/end/wall
            const costLabel = cell.querySelector('.cost-label');
            if (type === '' || type === 'open' || type === 'closed' || type === 'path') {
                const node = grid[row][col];
                costLabel.textContent = `f:${node.f}\ng:${node.g}\nh:${node.h}`;
            } else {
                costLabel.textContent = '';
            }
        }

        // Toggle wall
        function toggleWall(row, col) {
            if ((row === start.row && col === start.col) || (row === end.row && col === end.col)) {
                return; // Don't allow walls on start/end
            }
            grid[row][col].isWall = !grid[row][col].isWall;
            updateCell(row, col, grid[row][col].isWall ? 'wall' : '');
        }

        // Set start point
        function placeStart() {
            placingStart = true;
            placingEnd = false;
            alert("Click a cell to place START (Green)");
        }

        // Set end point
        function placeEnd() {
            placingEnd = true;
            placingStart = false;
            alert("Click a cell to place END (Red)");
        }

        // Reset grid
        function resetGrid() {
            initGrid();
        }

        // A* Pathfinding (with step-by-step visualization)
        async function findPath() {
            resetVisualization();
            
            const openSet = [];
            const closedSet = [];
            
            // Initialize start node
            grid[start.row][start.col].g = 0;
            grid[start.row][start.col].h = heuristic(start, end);
            grid[start.row][start.col].f = grid[start.row][start.col].g + grid[start.row][start.col].h;
            openSet.push(grid[start.row][start.col]);
            
            while (openSet.length > 0) {
                // Find node with lowest f in openSet
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                
                // Found the end!
                if (current.row === end.row && current.col === end.col) {
                    await reconstructPath(current);
                    return;
                }
                
                closedSet.push(current);
                if (!(current.row === start.row && current.col === start.col) && 
                    !(current.row === end.row && current.col === end.col)) {
                    updateCell(current.row, current.col, 'closed');
                    await sleep(animationSpeed);
                }
                
                // Check neighbors
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    if (closedSet.includes(neighbor) || neighbor.isWall) continue;
                    
                    const tempG = current.g + 1;
                    
                    if (tempG < neighbor.g || !openSet.includes(neighbor)) {
                        neighbor.g = tempG;
                        neighbor.h = heuristic(neighbor, end);
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.previous = current;
                        
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                            if (!(neighbor.row === end.row && neighbor.col === end.col)) {
                                updateCell(neighbor.row, neighbor.col, 'open');
                                await sleep(animationSpeed);
                            }
                        }
                    }
                }
            }
            
            alert("No path found! ðŸ˜¢");
        }

        // Heuristic (Manhattan distance)
        function heuristic(a, b) {
            return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);
        }

        // Get valid neighbors
        function getNeighbors(node) {
            const neighbors = [];
            const { row, col } = node;
            
            if (row > 0) neighbors.push(grid[row-1][col]);
            if (row < ROWS-1) neighbors.push(grid[row+1][col]);
            if (col > 0) neighbors.push(grid[row][col-1]);
            if (col < COLS-1) neighbors.push(grid[row][col+1]);
            
            return neighbors;
        }

        // Reconstruct path (with animation)
        async function reconstructPath(node) {
            let current = node;
            const path = [];
            
            while (current !== null) {
                path.unshift(current);
                current = current.previous;
            }
            
            // Highlight path (skip start and end)
            for (let i = 1; i < path.length - 1; i++) {
                updateCell(path[i].row, path[i].col, 'path');
                await sleep(animationSpeed);
            }
        }

        // Reset visualization colors
        function resetVisualization() {
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (!grid[row][col].isWall && 
                        !(row === start.row && col === start.col) && 
                        !(row === end.row && col === end.col)) {
                        grid[row][col].g = Infinity;
                        grid[row][col].h = 0;
                        grid[row][col].f = Infinity;
                        grid[row][col].previous = null;
                        updateCell(row, col, '');
                    }
                }
            }
        }

        // Helper function for animation delay
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize
        initGrid();
    </script>
</body>
</html>